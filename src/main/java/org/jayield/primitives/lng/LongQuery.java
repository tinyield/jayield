/*
 * Copyright (c) 2018, Fernando Miguel Carvalho, mcarvalho@cc.isel.ipl.pt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jayield.primitives.lng;

import org.jayield.Query;
import org.jayield.TraversableFinishError;
import org.jayield.Yield;
import org.jayield.boxes.BoolBox;
import org.jayield.boxes.LongBox;
import org.jayield.primitives.dbl.DoubleAdvancer;
import org.jayield.primitives.dbl.DoubleQuery;
import org.jayield.primitives.dbl.DoubleTraverser;
import org.jayield.primitives.intgr.IntAdvancer;
import org.jayield.primitives.intgr.IntQuery;
import org.jayield.primitives.intgr.IntTraverser;
import org.jayield.primitives.lng.ops.FromLongArray;
import org.jayield.primitives.lng.ops.LongConcat;
import org.jayield.primitives.lng.ops.LongDistinct;
import org.jayield.primitives.lng.ops.LongDropWhile;
import org.jayield.primitives.lng.ops.LongFilter;
import org.jayield.primitives.lng.ops.LongFlatMap;
import org.jayield.primitives.lng.ops.LongGenerate;
import org.jayield.primitives.lng.ops.LongIterate;
import org.jayield.primitives.lng.ops.LongLimit;
import org.jayield.primitives.lng.ops.LongMap;
import org.jayield.primitives.lng.ops.LongMapToObj;
import org.jayield.primitives.lng.ops.LongPeek;
import org.jayield.primitives.lng.ops.LongSkip;
import org.jayield.primitives.lng.ops.FromLongStream;
import org.jayield.primitives.lng.ops.LongTakeWhile;
import org.jayield.primitives.lng.ops.LongZip;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.LongSummaryStatistics;
import java.util.OptionalDouble;
import java.util.OptionalLong;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Function;
import java.util.function.LongBinaryOperator;
import java.util.function.LongConsumer;
import java.util.function.LongFunction;
import java.util.function.LongPredicate;
import java.util.function.LongSupplier;
import java.util.function.LongToDoubleFunction;
import java.util.function.LongToIntFunction;
import java.util.function.LongUnaryOperator;
import java.util.function.ObjLongConsumer;
import java.util.function.Supplier;
import java.util.stream.LongStream;
import java.util.stream.StreamSupport;

/**
 * A sequence of primitive long-valued elements supporting sequential
 * operations. This is the long primitive specialization of Query.
 */
public class LongQuery {

    private final LongAdvancer adv;
    private final LongTraverser trav;

    public LongQuery(LongAdvancer adv, LongTraverser trav) {
        this.adv = adv;
        this.trav = trav;
    }

    /**
     * Returns a sequential ordered {@code LongQuery} with elements
     * from the provided {@link LongStream} data.
     */
    public static LongQuery fromStream(LongStream src) {
        FromLongStream strm = new FromLongStream(src);
        return new LongQuery(strm, strm);
    }

    /**
     * Returns an infinite sequential ordered {@code LongQuery} produced by iterative
     * application of a function {@code f} to an initial element {@code seed},
     * producing a {@code LongQuery} consisting of {@code seed}, {@code f(seed)},
     * {@code f(f(seed))}, etc.
     */
    public static LongQuery iterate(long seed, LongUnaryOperator f) {
        LongIterate iter = new LongIterate(seed, f);
        return new LongQuery(iter, iter);
    }

    /**
     * Returns an infinite sequential unordered {@code LongQuery}
     * where each element is generated by the provided Supplier.
     */
    public static LongQuery generate(LongSupplier s) {
        LongGenerate gen = new LongGenerate(s);
        return new LongQuery(gen, gen);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void forEach(LongYield yield) {
        this.traverse(yield);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void traverse(LongYield yield) {
        this.trav.traverse(yield);
    }

    /**
     * If a remaining element exists, yields that element through
     * the given action.
     */
    public boolean tryAdvance(LongYield action) {
        return this.adv.tryAdvance(action);
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code LongQuery} that match
     * the given predicate.
     */
    public LongQuery filter(LongPredicate p) {
        LongFilter filter = new LongFilter(this, p);
        return new LongQuery(filter, filter);
    }

    /**
     * Returns a {@code LongQuery} consisting of the results of applying the given
     * LongUnaryOperator to the elements of this {@code LongQuery}.
     *
     * @param op
     *         LongUnaryOperator used to map the elements of this LongQuery
     */
    public LongQuery map(LongUnaryOperator op) {
        LongMap map = new LongMap(this, op);
        return new LongQuery(map, map);
    }

    /**
     * Returns a {@code Query} consisting of the results of applying the given
     * function to the elements of this {@code LongQuery}.
     *
     * @param function
     *         LongFunction used to map the elements of this LongQuery
     */
    public <U> Query<U> mapToObj(LongFunction<? extends U> function) {
        LongMapToObj<U> map = new LongMapToObj<>(this, function);
        return new Query<>(map, map);
    }

    /**
     * Returns a {@code LongQuery} consisting of the results of replacing each element of
     * this {@code LongQuery} with the contents of a mapped {@code LongQuery} produced by applying
     * the provided mapping function to each element.
     */
    public LongQuery flatMap(LongFunction<? extends LongQuery> function) {
        LongFlatMap map = new LongFlatMap(this, function);
        return new LongQuery(map, map);
    }

    /**
     * Returns a query consisting of the distinct elements (according to
     * {@link Object#equals(Object)}) of this query.
     */
    public LongQuery distinct() {
        LongDistinct dis = new LongDistinct(this);
        return new LongQuery(dis, dis);
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code LongQuery},
     * sorted according to the same logic as {@code Arrays.sort(long[] a)}.
     * <p>
     * This is a stateful intermediate operation.
     */
    public LongQuery sorted() {
        long[] state = this.toArray();
        Arrays.sort(state);
        FromLongArray arr = new FromLongArray(state);
        return new LongQuery(arr, arr);
    }

    /**
     * Returns an array containing the elements of this {@code LongQuery}.
     */
    public long[] toArray() {
        List<Long> list = toList();
        long[] result = new long[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    /**
     * Returns a List containing the elements of this {@code LongQuery}.
     */
    public List<Long> toList() {
        ArrayList<Long> result = new ArrayList<>();
        this.traverse(result::add);
        return result;
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code LongQuery}, additionally
     * performing the provided action on each element as elements are consumed
     * from the resulting {@code LongQuery}.
     */
    public LongQuery peek(LongConsumer action) {
        LongPeek peek = new LongPeek(this, action);
        return new LongQuery(peek, peek);
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this query, truncated
     * to be no longer than {@code n} in length.
     *
     * @param n
     *         maximum amount of elements to retrieve from this {@code LongQuery}
     */
    public LongQuery limit(int n) {
        LongLimit lim = new LongLimit(this, n);
        return new LongQuery(lim, lim);
    }

    /**
     * Returns a {@code LongQuery} consisting of the remaining elements of this {@code LongQuery}
     * after discarding the first {@code n} elements of the {@code LongQuery}.
     *
     * @param n
     *         number of elements to discard
     */
    public LongQuery skip(int n) {
        LongSkip skip = new LongSkip(this, n);
        return new LongQuery(skip, skip);
    }

    /**
     * Returns an {@link OptionalLong} with the resulting reduction of the elements of this {@code LongQuery},
     * if a reduction can be made, using the provided accumulator.
     */
    public OptionalLong reduce(LongBinaryOperator accumulator) {
        LongBox box = new LongBox();
        if(this.tryAdvance(box::setValue)) {
            return OptionalLong.of(this.reduce(box.getValue(), accumulator));
        } else {
            return OptionalLong.empty();
        }
    }

    /**
     * Returns the result of the reduction of the elements of this {@code LongQuery},
     * using the provided identity value and accumulator.
     */
    public long reduce(long identity, LongBinaryOperator accumulator) {
        class BoxAccumulator extends LongBox implements LongYield {
            public BoxAccumulator(long identity) {
                super(identity);
            }
            @Override
            public void ret(long item) {
                this.value = accumulator.applyAsLong(value, item);
            }
        }
        BoxAccumulator box = new BoxAccumulator(identity);
        this.traverse(box);
        return box.getValue();
    }

    /**
     * Returns the lowest long of this {@code LongQuery}
     */
    public OptionalLong min() {
        LongBox b = new LongBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e < b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalLong.of(b.getValue()) : OptionalLong.empty();
    }

    /**
     * Returns the highest long of this {@code LongQuery}
     */
    public OptionalLong max() {
        LongBox b = new LongBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e > b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalLong.of(b.getValue()) : OptionalLong.empty();
    }

    /**
     * Returns the count of elements in this {@code LongQuery}.
     */
    public final long count() {
        class Counter implements LongYield {
            long n = 0;

            @Override
            public void ret(long item) {
                ++n;
            }
        }
        Counter c = new Counter();
        this.traverse(c);
        return c.n;
    }

    /**
     * Returns an OptionalDouble describing the arithmetic mean of elements of this {@code LongQuery},
     * or an empty optional if this {@code LongQuery} is empty. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public OptionalDouble average() {
        long[] data = this.toArray();
        double count = data.length;
        if (count == 0) {
            return OptionalDouble.empty();
        }
        double sum = LongQuery.of(data).sum();
        return OptionalDouble.of(sum / count);
    }

    /**
     * Returns the sum of elements in this {@code LongQuery} .
     * <p>
     * This is a special case of a reduction.
     */
    public long sum() {
        return this.reduce(0, Long::sum);
    }

    /**
     * Returns a sequential ordered {@code LongQuery} whose elements
     * are the specified values in data parameter.
     */
    public static LongQuery of(long... data) {
        FromLongArray arr = new FromLongArray(data);
        return new LongQuery(arr, arr);
    }

    /**
     * Returns an LongSummaryStatistics describing various summary data about
     * the elements of this {@code LongQuery}. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public LongSummaryStatistics summaryStatistics() {
        return this.collect(LongSummaryStatistics::new, LongSummaryStatistics::accept);
    }

    /**
     * Performs a mutable reduction operation on the elements of this {@code LongQuery}.
     * A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList,
     * and elements are incorporated by updating the state of the result rather than by replacing the result.
     */
    public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator) {
        R result = supplier.get();
        this.traverse(elem -> accumulator.accept(result, elem));
        return result;
    }

    /**
     * Returns whether all elements of this {@code LongQuery} match the provided
     * {@link LongPredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         LongPredicate used to test elements of this {@code LongQuery}
     */
    public boolean allMatch(LongPredicate p) {
        BoolBox succeed = new BoolBox(true);
        shortCircuit(item -> {
            if (!p.test(item)) {
                succeed.set(false);
                Yield.bye();
            }
        });
        return succeed.isTrue();
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or the traversal
     * exited normally through the invocation of yield.bye().
     */
    public final void shortCircuit(LongYield yield) {
        try {
            this.trav.traverse(yield);
        } catch (TraversableFinishError e) {
            /* Proceed */
        }
    }

    /**
     * Returns whether no elements of this {@code LongQuery} match the provided
     * {@link LongPredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         LongPredicate used to test elements of this {@code LongQuery}
     */
    public boolean noneMatch(LongPredicate p) {
        return !this.anyMatch(p);
    }

    /**
     * Returns whether any elements of this {@code LongQuery} match the provided
     * {@link LongPredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code false} is returned and the predicate is not evaluated.
     *
     * @param p
     *         LongPredicate used to test elements of this {@code LongQuery}
     */
    public boolean anyMatch(LongPredicate p) {
        BoolBox found = new BoolBox();
        shortCircuit(item -> {
            if (p.test(item)) {
                found.set();
                Yield.bye();
            }
        });
        return found.isTrue();
    }

    /**
     * Returns an {@link OptionalLong} describing any element of this {@code LongQuery},
     * or an empty {@code OptionalLong} if this {@code LongQuery} is empty.
     */
    public OptionalLong findAny() {
        return this.findFirst();
    }

    /**
     * Returns an {@link OptionalLong} describing the first element of this {@code LongQuery},
     * or an empty {@code OptionalLong} if this {@code LongQuery} is empty.
     */
    public OptionalLong findFirst() {
        LongBox box = new LongBox();
        this.tryAdvance(box::turnPresent);
        return box.isPresent()
                ? OptionalLong.of(box.getValue())
                : OptionalLong.empty();
    }

    /**
     * Returns a {@code IntQuery} consisting of the elements of this {@code LongQuery},
     * converted to int.
     * <p>
     * This is an intermediate operation.
     */
    public IntQuery asIntQuery() {
        return this.mapToInt(i -> (int) i);
    }

    /**
     * Returns a {@code IntQuery} consisting of the results of applying the given
     * function to the elements of this {@code LongQuery}.
     *
     * @param function
     *         LongToIntFunction used to map the elements of this LongQuery
     */
    public IntQuery mapToInt(LongToIntFunction function) {
        return new IntQuery(IntAdvancer.from(adv, function), IntTraverser.from(trav, function));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code LongQuery},
     * converted to double.
     * <p>
     * This is an intermediate operation.
     */
    public DoubleQuery asDoubleQuery() {
        return this.mapToDouble(i -> i);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the results of applying the given
     * function to the elements of this {@code LongQuery}.
     *
     * @param function
     *         LongToDoubleFunction used to map the elements of this LongQuery
     */
    public DoubleQuery mapToDouble(LongToDoubleFunction function) {
        return new DoubleQuery(DoubleAdvancer.from(adv, function), DoubleTraverser.from(trav, function));
    }

    /**
     * Returns a Stream consisting of the elements of this {@code LongQuery},
     * each boxed to an Long.
     */
    public Query<Long> boxed() {
        return new Query<>(adv, trav);
    }

    public LongStream toStream() {
        Spliterator.OfLong iter = new Spliterators.AbstractLongSpliterator(Long.MAX_VALUE, Spliterator.ORDERED) {
            @Override
            public boolean tryAdvance(LongConsumer action) {
                return adv.tryAdvance(action::accept);
            }

            @Override
            public void forEachRemaining(LongConsumer action) {
                trav.traverse(action::accept);
            }
        };
        return StreamSupport.longStream(iter, false);
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain into a function.
     * That function {@code next} is applied to this {@code DoubleQuery} to produce a new
     * {@code LongTraverser} object that is encapsulated in the resulting {@code DoubleQuery}.
     * On the other hand, the {@code nextAdv} is applied to this query to produce a new
     * {@code LongAdvancer} object that is encapsulated in the resulting query.
     */
    public final LongQuery then(
        Function<LongQuery, LongAdvancer> nextAdv,
        Function<LongQuery, LongTraverser> next)
    {
        return new LongQuery(nextAdv.apply(this), next.apply(this));
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain longo a function.
     * That function {@code next} is applied to this {@code LongQuery} to produce a new
     * {@code LongTraverser} object that is encapsulated in the resulting {@code LongQuery}.
     */
    public final LongQuery then(Function<LongQuery, LongTraverser> next) {
        LongAdvancer nextAdv = item -> { throw new UnsupportedOperationException(
            "Missing tryAdvance() implementation! Use the overloaded then() providing both Advancer and Traverser!");
        };
        return new LongQuery(nextAdv, next.apply(this));
    }

    /**
     * Returns a {@code LongQuery} consisting of the longest prefix of elements taken from
     * this {@code LongQuery} that match the given predicate.
     */
    public final LongQuery takeWhile(LongPredicate predicate) {
        LongTakeWhile take = new LongTakeWhile(this, predicate);
        return new LongQuery(take, take);
    }

    /**
     * Creates a concatenated {@code Query} in which the elements are
     * all the elements of this {@code Query} followed by all the
     * elements of the other {@code Query}.
     */
    public final LongQuery concat(LongQuery other) {
        LongConcat cat = new LongConcat(this, other);
        return new LongQuery(cat, cat);
    }

    /**
     * Returns a {@code LongQuery} consisting of the remaining elements of this query
     * after discarding the first sequence of elements that match the given Predicate.
     */
    public final LongQuery dropWhile(LongPredicate predicate) {
        LongDropWhile drop = new LongDropWhile(this, predicate);
        return new LongQuery(drop, drop);
    }

    /**
     * Applies a specified function to the corresponding elements of two
     * sequences, producing a sequence of the results.
     */
    public final LongQuery zip(LongQuery other, LongBinaryOperator zipper) {
        LongZip zip = new LongZip(this, other, zipper);
        return new LongQuery(zip, zip);
    }
}
